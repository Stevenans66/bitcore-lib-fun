{"version":3,"sources":["../../lib/util.ts","slpwallet/Utils.ts","App.tsx","logo.svg","CacheSet.ts","slpwallet/Network.ts","reportWebVitals.js","slpwallet/Storage.ts","slpwallet/index.ts","index.tsx","../../lib/tokentype1.ts","../../lib/nft1.ts","slpwallet/TxBuilder.ts","../../lib/index.ts","slpwallet/Wallet.ts"],"names":["buf","length","Utils","hash","hashHex","Buffer","from","toString","txid","Uint8Array","match","map","byte","parseInt","reverse","index","isTxid","indexBuf","alloc","writeUInt32BE","hashToTxid","outpoint","slice","vout","voutBuf","readUInt32BE","sleep","ms","Promise","resolve","setTimeout","TxnErrorTypes","myTableStyle","border","App","props","domWallet","DomWallet","mounted","validateAddOutput","bchaddr","isValidAddress","state","outputAddressValue","txnValidationErrors","delete","INVALID_OUTPUT_ADDRESS","selectedSlpTokenId","isSlpAddress","NON_SLP_ADDRESS","add","Big","outputAmountValue","INVALID_OUTPUT_AMOUNT","_","txn","currentTxn","lt","BELOW_DUST_LIMIT","unspentAmt","Array","Wallet","BchCoins","reduce","p","c","i","satoshis","Outputs","gt","LOW_BCH_INPUTS","tokenAmt","getTokenAmount","ZERO_SLP_OUTPUT","tokenId","slpCoins","SlpCoins","get","unspentSlpAmt","amount","slpChangeAmt","SlpChangeOutput","SlpOutputs","sub","LOW_SLP_INPUTS","changeDust","DUST_LIMIT","opReturnSize","unspentBchAmt","TOO_MANY_SLP_DECIMAL_PLACES","size","forceUpdate","updateOutputAddress","event","target","value","setState","outputAddressValid","updateSelectedToken","TxBuilder","selectedIndex","TokenMetadata","updateOutputValue","outputAmountValid","clearTransaction","clear","sendTransaction","a","SignTransaction","PrivateKey","txnHex","fee","sendAmount","console","log","Confirm","SendTransaction","Alert","message","addOutput","addr","toCashAddress","val","AddBchOutput","Address","toNumber","AddSlpOutput","importMnemonic","userValue","UpdateMnemonic","address","showPrivKey","showSlpAddressFormat","LoadInitialBalances","toggleAddrFormat","toSlpAddress","useMainnet","toTestnetAddress","toggleMnemonic","checkingBalance","showCoins","showTxnInputs","showBchHistory","showSlpHistory","slpOutputs","Set","this","Subscribe","className","href","rel","src","logo","alt","width","height","hidden","defaultValue","Mnemonic","onChange","XPub","onClick","style","GetBchBalance","div","toFixed","GetSlpBalances","b","getTokenName","getSlpAmountString","keyToOutpointString","coins","getTokenTypeString","htmlFor","id","placeholder","getTokenTicker","err","Inputs","input","outpointToKey","prevTxId","outputIndex","slpOut","slpOutpointCache","output","script","isDataOut","toBuffer","slpOuts","toAddress","decimals","tm","hasType1","getType1","getDecimals","hasNft1Group","getNft1Group","hasNft1Child","Error","mul","has","nameBuf","getTokenTicker_asU8","getNft1Child","getTokenName_asU8","getTypeMetadataCase","TypeMetadataCase","TYPE1","NFT1_GROUP","NFT1_CHILD","Component","Symbol","iterator","CacheSet","maxSize","set","list","values","item","shift","push","filter","k","pop","Network","url","networkUrl","subscriptions","blockInfo","blockData","blockHeight","callback","client","GrpcClient","submitTransaction","res","getHash_asU8","getTransaction","reversedHashOrder","tokenIds","getTokenMetadata","sinceBlock","getBlockchainInfo","getSlpIndex","getAddressTransactions","addresses","onTransactionNotification","createTxnStream","subscribeTransactions","includeMempoolAcceptance","includeBlockAcceptance","includeSerializedTxn","txnStream","on","error","data","getUnconfirmedTransaction","createBlockDataStream","subscribeBlocks","includeSerializedBlock","blockDataStream","createBlockInfoStream","blockInfoStream","getBlockInfo","getHeight","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","BrowserLocalStorage","localStorage","getItem","seed","setItem","app","storage","network","Ready","Storage","undefined","window","global","require","ReactDOM","render","StrictMode","document","getElementById","exports","default","Group","genesis","SlpVersionType","wallet","Transaction","slpOpreturnMessage","inputs","outputs","o","slpAmt","_changeScript","_changeIndex","removeOutput","Output","Script","addSlpInputs","addBchInputs","to","getKeys","pk","sign","serialize","inputAmount","outputAmount","change","checkInputs","feePerByte","feeRate","GetFeeRate","bchCoins","sort","coin","skipCoin","addInput","Input","PublicKeyHash","buildPublicKeyHashOut","empty","amounts","amts","n","mdm","getTokenType","TokenVersionType1","send","TokenVersionType1_NFT_Group","TokenVersionType1_NFT_Child","Child","checkSlpInputs","slpInputAmt","slpOutputAmt","minus","gte","createMd","txidsSeen","addressPath","parent","Map","mnemonic","privateKey","bchTxi","bchTxo","slpTxi","slpTxo","tokenMetadata","loadingBalance","updateParent","UpdateWalletUI","bip39","bip32","child","derivePath","toWIF","GetSeed","SetSeed","_estimateSize","EstimateTxnSize","rate","forEach","isMine","GetAddressTransactions","indexTransactionIO","getConfirmedTransactionsList","getUnconfirmedTransactionsList","m","inputAmt","slpBals","bal","outs","processNewTransaction","GetTransaction","txns","tx","getInputsList","inp","includes","getAddress","op","getOutpoint","getIndex","hasSlpToken","_tokenId","getSlpToken","getTokenId_asU8","getAmount","getValue","e","getOutputsList","out","GetTokenMetadata","keys","getTokenMetadataList","neutered","toBase58","_bip39","dat","_coins","coinMap"],"mappings":"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","file":"static/js/main.01188203.chunk.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pushdata = (buf) => {\n    if (buf.length === 0) {\n        return Buffer.from([0x4C, 0x00]);\n    }\n    else if (buf.length < 0x4E) {\n        return Buffer.concat([Buffer.from([buf.length]), buf]);\n    }\n    else if (buf.length < 0xFF) {\n        return Buffer.concat([Buffer.from([0x4c, buf.length]), buf]);\n    }\n    else if (buf.length < 0xFFFF) {\n        const tmp = Buffer.allocUnsafe(2);\n        tmp.writeUInt16LE(buf.length, 0);\n        return Buffer.concat([Buffer.from([0x4d]), tmp, buf]);\n    }\n    else if (buf.length < 0xFFFFFFFF) {\n        const tmp = Buffer.allocUnsafe(4);\n        tmp.writeUInt32LE(buf.length, 0);\n        return Buffer.concat([Buffer.from([0x4e]), tmp, buf]);\n    }\n    else {\n        throw new Error('does not support bigger pushes yet');\n    }\n};\nexports.BNToInt64BE = (bn) => {\n    if (!bn.isInteger()) {\n        throw new Error('bn not an integer');\n    }\n    if (!bn.isPositive()) {\n        throw new Error('bn not positive integer');\n    }\n    const h = bn.toString(16);\n    if (h.length > 16) {\n        throw new Error('bn outside of range');\n    }\n    return Buffer.from(h.padStart(16, '0'), 'hex');\n};\nexports.createOpReturnGenesis = (versionType, ticker, name, documentUrl, documentHash, decimals, mintBatonVout, quantity) => {\n    if (![0x01, 0x41, 0x81].includes(versionType)) {\n        throw new Error('unknown versionType');\n    }\n    if (typeof (documentHash) === 'string') {\n        if (documentHash.length !== 0 && documentHash.length !== 64) {\n            throw new Error('documentHash must be either 0 or 32 hex bytes');\n        }\n        if (documentHash.length === 64 && !documentHash.match(/^[0-9a-fA-F]{64}$/)) {\n            throw new Error('documentHash must be hex');\n        }\n        documentHash = Buffer.from(documentHash, 'hex');\n    }\n    else {\n        if (documentHash.length !== 0 && documentHash.length !== 32) {\n            throw new Error('documentHash must be either 0 or 32 hex bytes');\n        }\n    }\n    if (decimals < 0 || decimals > 9) {\n        throw new Error('decimals out of range');\n    }\n    if (mintBatonVout !== null) {\n        if (mintBatonVout < 2 || mintBatonVout > 0xFF) {\n            throw new Error('mintBatonVout out of range (0x02 < > 0xFF)');\n        }\n    }\n    if (versionType === 0x41) {\n        if (!quantity.isEqualTo(1)) {\n            throw new Error('quantity must be 1 for NFT1 child genesis');\n        }\n        if (decimals !== 0) {\n            throw new Error('decimals must be 0 for NFT1 child genesis');\n        }\n        if (mintBatonVout !== null) {\n            throw new Error('mintBatonVout must be null for NFT1 child genesis');\n        }\n    }\n    const buf = Buffer.concat([\n        Buffer.from([0x6A]),\n        exports.pushdata(Buffer.from(\"SLP\\0\")),\n        exports.pushdata(Buffer.from([versionType])),\n        exports.pushdata(Buffer.from(\"GENESIS\")),\n        exports.pushdata(Buffer.from(ticker)),\n        exports.pushdata(Buffer.from(name)),\n        exports.pushdata(Buffer.from(documentUrl)),\n        exports.pushdata(documentHash),\n        exports.pushdata(Buffer.from([decimals])),\n        exports.pushdata(Buffer.from(mintBatonVout === null ? [] : [mintBatonVout])),\n        exports.pushdata(exports.BNToInt64BE(quantity)),\n    ]);\n    return buf;\n};\nexports.createOpReturnMint = (versionType, tokenIdHex, mintBatonVout, quantity) => {\n    if (![0x01, 0x41, 0x81].includes(versionType)) {\n        throw new Error('unknown versionType');\n    }\n    if (typeof (tokenIdHex) === 'string') {\n        if (!tokenIdHex.match(/^[0-9a-fA-F]{64}$/)) {\n            throw new Error('tokenIdHex does not pass regex');\n        }\n        if (tokenIdHex.length !== 64) {\n            throw new Error('tokenIdHex must be 32 bytes');\n        }\n        tokenIdHex = Buffer.from(tokenIdHex, 'hex');\n    }\n    else {\n        if (tokenIdHex.length !== 32) {\n            throw new Error('tokenIdHex must be 32 bytes');\n        }\n    }\n    if (mintBatonVout !== null) {\n        if (mintBatonVout < 2 || mintBatonVout > 0xFF) {\n            throw new Error('mintBatonVout out of range (0x02 < > 0xFF)');\n        }\n    }\n    const buf = Buffer.concat([\n        Buffer.from([0x6A]),\n        exports.pushdata(Buffer.from(\"SLP\\0\")),\n        exports.pushdata(Buffer.from([versionType])),\n        exports.pushdata(Buffer.from(\"MINT\")),\n        exports.pushdata(tokenIdHex),\n        exports.pushdata(Buffer.from(mintBatonVout === null ? [] : [mintBatonVout])),\n        exports.pushdata(exports.BNToInt64BE(quantity)),\n    ]);\n    return buf;\n};\nexports.createOpReturnSend = (versionType, tokenIdHex, slpAmounts) => {\n    if (![0x01, 0x41, 0x81].includes(versionType)) {\n        throw new Error('unknown versionType');\n    }\n    if (typeof (tokenIdHex) === 'string') {\n        if (!tokenIdHex.match(/^[0-9a-fA-F]{64}$/)) {\n            throw new Error('tokenIdHex does not pass regex');\n        }\n        if (tokenIdHex.length !== 64) {\n            throw new Error('tokenIdHex must be 32 bytes');\n        }\n        tokenIdHex = Buffer.from(tokenIdHex, 'hex');\n    }\n    else {\n        if (tokenIdHex.length !== 32) {\n            throw new Error('tokenIdHex must be 32 bytes');\n        }\n    }\n    if (slpAmounts.length < 1) {\n        throw new Error('send requires at least one amount');\n    }\n    if (slpAmounts.length > 19) {\n        throw new Error('too many slp amounts');\n    }\n    const buf = Buffer.concat([\n        Buffer.from([0x6A]),\n        exports.pushdata(Buffer.from(\"SLP\\0\")),\n        exports.pushdata(Buffer.from([versionType])),\n        exports.pushdata(Buffer.from(\"SEND\")),\n        exports.pushdata(tokenIdHex),\n        ...slpAmounts.map(v => exports.pushdata(exports.BNToInt64BE(v))),\n    ]);\n    return buf;\n};\n//# sourceMappingURL=util.js.map","\n\nexport class Utils {\n  // this prevents us from getting into trouble with the reverse() function\n  public static hashToTxid(hash: Uint8Array): string {\n    const hashHex = Buffer.from(hash).toString(\"hex\");\n    const txid = new Uint8Array(hashHex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16))).reverse();\n    return Buffer.from(txid).toString(\"hex\");\n  }\n\n  public static outpointToKey(hash: Uint8Array, index: number, isTxid=false): string {\n    const indexBuf = Buffer.alloc(4);\n    indexBuf.writeUInt32BE(index);\n    if (!isTxid) {\n      return Utils.hashToTxid(hash) + indexBuf.toString(\"hex\");\n    }\n    return Buffer.from(hash).toString(\"hex\") + indexBuf.toString(\"hex\");\n  }\n\n  public static keyToOutpointString(outpoint: string): string {\n    const txid = outpoint.slice(0, 64);\n    const vout = outpoint.slice(64, 72);\n    const voutBuf = Buffer.from(vout, \"hex\");\n    return `${txid}:${voutBuf.readUInt32BE(0)}`;\n  }\n\n  public static sleep = (ms: number) => new Promise<void>(resolve => setTimeout(resolve, ms));\n}\n\nexport default Utils;\n","import React, { Component } from \"react\";\nimport { Confirm, Alert } from 'react-st-modal';\nimport \"./App.css\";\nimport logo from \"./logo.svg\";\nimport QRCode from \"qrcode.react\";\n\nimport bchaddr from \"bchaddrjs-slp\";\nimport { Big } from \"big.js\";\nimport { TokenMetadata } from \"grpc-bchrpc-web/pb/bchrpc_pb\";\n\nimport { Address } from \"bitcore-lib-cash\";\nimport { DUST_LIMIT, TxBuilder } from \"./slpwallet/TxBuilder\";\nimport { DomWallet } from \"./slpwallet\";\nimport Utils from \"./slpwallet/Utils\";\n\ninterface IProps {}\n\ninterface IState {\n  showPrivKey?: boolean;\n  showSlpAddressFormat?: boolean;\n  useMainnet?: boolean;\n  address?: string;\n  checkingBalance?: boolean;\n  showCoins?: boolean;\n  showTxnInputs?: boolean;\n  showBchHistory?: boolean;\n  showSlpHistory?: boolean;\n  outputAddressValue?: string;\n  outputAddressValid?: boolean;\n  outputAmountValue?: string;\n  outputAmountValid?: boolean;\n  selectedSlpTokenId?: string;\n  slpOutputs?: Array<Big>;\n  slpChangeAmt?: Big;\n  currentTxn?: TxBuilder;\n  txnValidationErrors?: Set<string>;\n}\n\nenum TxnErrorTypes {\n  LOW_BCH_INPUTS = \"insufficient bch inputs\",\n  LOW_SLP_INPUTS = \"insufficient slp inputs\",\n  INVALID_OUTPUT_ADDRESS = \"invalid address\",\n  NON_SLP_ADDRESS = \"address isn't slp format\",\n  INVALID_OUTPUT_AMOUNT = \"invalid amount\",\n  BELOW_DUST_LIMIT = \"output is lower than dust limit\",\n  ZERO_SLP_OUTPUT = \"must have slp output > 0\",\n  TOO_MANY_SLP_DECIMAL_PLACES = \"too many decimal places for this slp token\"\n}\n\nconst myTableStyle = {\n  border:\"2px solid grey\", \n  \"marginLeft\": \"auto\",\n  \"marginRight\": \"auto\"\n} as React.CSSProperties;\n\n\nclass App extends Component<IProps, IState> {\n  private readonly domWallet: DomWallet = new DomWallet(this);\n  private mounted = false;\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.state = {\n      showPrivKey: false,\n      showSlpAddressFormat: true,\n      address: bchaddr.toSlpAddress(this.domWallet.Wallet.Address.toCashAddress()),\n      useMainnet: true,\n      checkingBalance: true,\n      showCoins: false,\n      showTxnInputs: false,\n      showBchHistory: false,\n      showSlpHistory: false,\n      outputAddressValue: \"\",\n      outputAddressValid: false,\n      outputAmountValue: \"\",\n      outputAmountValid: false,\n      selectedSlpTokenId: \"bch\",\n      slpOutputs: [],\n      currentTxn: new TxBuilder(this.domWallet.Wallet),\n      txnValidationErrors: new Set<string>()\n    };\n  }\n\n  public componentDidMount() {\n    this.mounted = true;\n    this.domWallet.Wallet.Subscribe();\n  }\n\n  public UpdateWalletUI() {\n    if (this.mounted) {\n      this.forceUpdate();\n    }\n  }\n\n  public render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n            {/* Learn more about BCH! */}\n            <br/>\n            <a\n              className=\"App-link\"\n              href=\"https://bch.info\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              <img src={logo} className=\"App-logo\" alt=\"logo\" width=\"30%\" height=\"30%\"/>\n            </a> <h3>Web Wallet</h3>\n        </header>\n          {/* Display private key backup! */}\n          <br/><br/>\n          <strong>Back up your funds with your 12-word seed phase!!!</strong><br/>\n          <div hidden={!this.state.showPrivKey}>\n            Seed Phrase:<br/><input defaultValue={this.domWallet.Wallet.Mnemonic} onChange={this.importMnemonic}/><br/>\n            Xpub:<br/>{this.domWallet.Wallet.XPub}\n          </div>\n          <button\n            onClick={this.toggleMnemonic}\n          >\n            {this.state.showPrivKey ? \"Hide\" : \"Show\"} Seed Phrase\n          </button>\n\n          {/* Display network mode */}\n          {/* <p>\n            <strong>BCHD Network:</strong><br/>\n            {this.state.useMainnet ? \"Mainnet\" : \"Testnet3\" }<br/>\n            ({this.domWallet.Wallet.NetworkUrl})<br/>\n            <button\n              onClick={this.toggleNetwork}\n            >\n              Switch to {this.state.useMainnet ? \"testnet3\" : \"mainnet\" }\n            </button>\n          </p> */}\n\n          {/* Display address */}\n          <p>\n            <strong>Your wallet address:</strong><br/>\n            {this.state.address!}<br/>\n            <button\n            onClick={this.toggleAddrFormat}\n            >\n              Switch to {this.state.showSlpAddressFormat ? \"cash\" : \"slp\" }Addr format\n            </button>\n          </p>\n          <QRCode value={this.state.address!} /><br/>\n\n          {/* Display SLP token balances */}\n          <div hidden={this.domWallet.Wallet.SlpCoins.size === 0}>\n            <strong>Balances:</strong><br/>\n            <table style={myTableStyle}>\n              <thead><tr><th>name</th><th>amount</th></tr></thead>\n              <tbody>\n                <tr key=\"bch-bal\"><td>BCH</td><td>{this.domWallet.Wallet.GetBchBalance().div(10**8).toFixed(8)}</td></tr>\n              {\n                Array.from(this.domWallet.Wallet.GetSlpBalances()).map(b => {\n                  return (<tr key={`${b[0]}-bal`}><td>{this.getTokenName(b[0])}</td><td>{this.getSlpAmountString(b[1], b[0])}</td></tr>);\n                })\n              }\n              </tbody>\n            </table>\n          </div><br/>\n          <p hidden={this.domWallet.Wallet.SlpCoins!.size !== 0}>\n            No BCH or SLP balance.\n          </p>\n\n          {/* BCH Txn History */}\n          <div hidden={this.domWallet.Wallet.BchCoins.size === 0}>\n            <button\n              onClick={() => this.setState({ showBchHistory: !this.state.showBchHistory })}\n            >\n              {this.state.showBchHistory ? \"Hide\" : \"Show\"} BCH History\n            </button>\n          </div>\n          <div hidden={!this.state.showBchHistory}>\n            --BCH HISTORY HERE--\n          </div><br/>\n\n\n          {/* SLP Transaction History */}\n          <div hidden={this.domWallet.Wallet.SlpCoins.size === 0}>\n            <button\n              onClick={() => this.setState({ showSlpHistory: !this.state.showSlpHistory })}\n            >\n              {this.state.showSlpHistory ? \"Hide\" : \"Show\"} SLP History\n            </button>\n          </div>\n          <div hidden={!this.state.showSlpHistory}>\n            --SLP HISTORY HERE--\n          </div><br/>\n\n          {/* Coins */}\n          <div hidden={this.domWallet.Wallet.BchCoins.size === 0 && this.domWallet.Wallet.SlpCoins.size === 0}>\n            <button\n              onClick={() => this.setState({ showCoins: !this.state.showCoins })}\n            >\n              {this.state.showCoins ? \"Hide\" : \"Show\"} Unspent Coins\n            </button>\n          </div>\n          <div hidden={!this.state.showCoins}>\n            <strong>Unspent Coins</strong>\n            <table style={myTableStyle}>\n              <thead><tr><th>UTXO</th><th>Value</th><th>Name</th></tr></thead>\n              <tbody>\n                {Array.from(this.domWallet.Wallet.BchCoins).map(c => {\n                  return (<tr key={c[0]}><td>{Utils.keyToOutpointString(c[0])}</td><td>{c[1].satoshis.div(10**8).toFixed(8)}</td><td>BCH</td></tr>);\n                })}\n                {Array.from(this.domWallet.Wallet.SlpCoins).map(([tokenId, coins]) => {\n                  return Array.from(coins).map(c => {\n                    return (<tr key={c[0]}><td>{Utils.keyToOutpointString(c[0])}</td><td>{this.getSlpAmountString(c[1].amount, tokenId)}</td><td>{this.getTokenName(tokenId)}</td></tr>);\n                  })\n                })}\n              </tbody>\n            </table>\n          </div><br/>\n\n          {/* Create a Transaction */}\n          <strong>Create a Transaction</strong><br/>\n          <select value={this.state.selectedSlpTokenId} onChange={this.updateSelectedToken}>\n            {Array.from(this.domWallet.Wallet.SlpCoins).map(([tokenId, _]) => (<option key={tokenId} value={tokenId}>{`SLP -> ${this.getTokenName(tokenId)} (${this.getTokenTypeString(tokenId)})`}</option>))}\n            <option key=\"bch\" value=\"bch\">Bitcoin Cash</option>\n          </select><br/>\n          <label htmlFor=\"payto\">PayTo:</label><br/>\n          <input id=\"payto\" value={this.state.outputAddressValue} placeholder={this.state.selectedSlpTokenId! === \"bch\" ? \"cash or slp address\" : \"slp address\"} onChange={this.updateOutputAddress}></input><br/>\n          <label htmlFor=\"amount\">Amount:</label><br/>\n          <input id=\"amount\" value={this.state.outputAmountValue} placeholder={this.getTokenTicker()} onChange={this.updateOutputValue}></input><br/>\n          <button onClick={this.addOutput}>Add Output</button><br/>\n          <div hidden={this.state.txnValidationErrors!.size === 0}>\n            <br/><strong>Validation Errors</strong>\n            <table style={myTableStyle}>\n              <tbody>\n                {Array.from(this.state.txnValidationErrors!).map((err, i) => {\n                    return (<tr key={i}><td>{err}</td></tr>);\n                })}\n              </tbody>\n            </table>\n          </div><br/>\n\n          {/* Show Txn Inputs */}\n          <div hidden={this.state.currentTxn!.Inputs.length === 0}>\n            <div hidden={!this.state.showTxnInputs!}>\n              Txn Inputs\n              <table style={myTableStyle}>\n                <tbody>\n                  {Array.from(this.state.currentTxn!.Inputs).map((input, i) => {\n                    let outpoint = Utils.outpointToKey(input.prevTxId, input.outputIndex, true);\n                    let slpOut = this.domWallet.Wallet.slpOutpointCache.get(outpoint)!;\n                    if (slpOut) {\n                      return (<tr key={i}><td>{`${input.prevTxId.toString(\"hex\")}:${input.outputIndex}, ${this.getSlpAmountString(slpOut.amount, slpOut.tokenId)} ${this.getTokenTicker(slpOut.tokenId)}, ${slpOut.satoshis} sats`}</td></tr>);\n                    }\n                    return (<tr key={i}><td>{`${input.prevTxId.toString(\"hex\")}:${input.outputIndex}, ${input.output!.satoshis} sats`}</td></tr>);\n                  })}\n                </tbody>\n              </table>\n            </div>\n            <button\n              onClick={() => this.setState({ showTxnInputs: !this.state.showTxnInputs })}\n            >\n              {this.state.showTxnInputs! ? \"Hide\" : \"Show\"} Transaction Inputs\n            </button>\n          </div><br/>\n\n          {/* Show Txn Outputs */}\n          <div hidden={this.state.currentTxn!.Outputs.length === 0}>\n            <strong>Txn Outputs</strong>\n            <table style={myTableStyle}>\n              <tbody>\n                  {Array.from(this.state.currentTxn!.Outputs).map((output, i) => {\n                    if (output[0].script.isDataOut()) {\n                      return (<tr key={i}><td>{`SLP Metadata message, ${output[0].script.toBuffer().length} bytes, ${output[0].satoshis} sats`}</td></tr>);\n                    }\n                    let slpOuts = this.state.currentTxn!.SlpOutputs;\n                    if (i <= slpOuts.length) {\n                      return (<tr key={i}><td>{`${output[0].script.toAddress().toCashAddress()}, ${this.getSlpAmountString(slpOuts[i-1])} ${this.getTokenTicker()}, ${output[0].satoshis} sats`}</td></tr>);\n                    }\n                    return (<tr key={i}><td>{`${output[0].script.toAddress().toCashAddress()}, ${output[0].satoshis} sats`}</td></tr>);\n                  })}\n              </tbody>\n            </table><br/>\n          </div><br/>\n\n          <div hidden={this.state.currentTxn!.Outputs.length === 0 || this.state.txnValidationErrors!.size !== 0}>\n            <button onClick={this.sendTransaction}>Send</button>\n          </div>\n          <div>\n            <button onClick={this.clearTransaction}>Clear</button>\n          </div><br/>\n        </div>\n    );\n  }\n\n  public setState(state: IState) {\n    return new Promise((resolve: any) => {\n      super.setState(state, resolve);\n    });\n  }\n\n  private validateAddOutput = (): number => {\n\n    // address input box\n    if (bchaddr.isValidAddress(this.state.outputAddressValue!)) {\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.INVALID_OUTPUT_ADDRESS);\n      if (this.state.selectedSlpTokenId !== \"bch\" && !bchaddr.isSlpAddress(this.state.outputAddressValue!)) {\n        this.state.txnValidationErrors!.add(TxnErrorTypes.NON_SLP_ADDRESS);\n      } else if (this.state.selectedSlpTokenId !== \"bch\") {\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.NON_SLP_ADDRESS);\n      }\n    } else {\n      this.state.txnValidationErrors!.add(TxnErrorTypes.INVALID_OUTPUT_ADDRESS);\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.NON_SLP_ADDRESS);\n    }\n\n    // amount input box\n    try {\n      Big(this.state.outputAmountValue!);\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.INVALID_OUTPUT_AMOUNT);\n    } catch (_) {\n      this.state.txnValidationErrors!.add(TxnErrorTypes.INVALID_OUTPUT_AMOUNT);\n    }\n\n    const txn = this.state.currentTxn!;\n    if (this.state.selectedSlpTokenId === \"bch\") {\n      if (this.state.outputAmountValue && Big(this.state.outputAmountValue!).lt(546)) {\n        this.state.txnValidationErrors!.add(TxnErrorTypes.BELOW_DUST_LIMIT);\n      } else {\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.BELOW_DUST_LIMIT);\n      }\n\n      if (this.state.outputAmountValue) {\n        const unspentAmt = Array.from(this.domWallet.Wallet.BchCoins).reduce((p, c, i) => p.add(c[1].satoshis), Big(0))\n        const outputAmt = txn.Outputs.reduce((p, c, i) => p.add(c[0].satoshis), Big(0)).add(this.state.outputAmountValue!);\n        if (outputAmt.gt(unspentAmt)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.LOW_BCH_INPUTS);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n        }\n      } else {\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n      }\n\n    } else {\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.BELOW_DUST_LIMIT);\n      this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n\n      // check slp balance\n      if (this.state.outputAmountValue!) {\n\n        const tokenAmt = this.getTokenAmount(new Big(this.state.outputAmountValue!), this.state.selectedSlpTokenId!);\n\n        if (this.state.outputAmountValue && tokenAmt.lt(1)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.ZERO_SLP_OUTPUT);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.ZERO_SLP_OUTPUT);\n        }\n\n        const tokenId = this.state.selectedSlpTokenId!;\n        const slpCoins = this.domWallet.Wallet.SlpCoins.get(tokenId)!;\n        const unspentSlpAmt = Array.from(slpCoins).reduce((p, c, i) => p.add(c[1].amount), Big(0));\n        const slpChangeAmt = this.state.currentTxn!.SlpChangeOutput ? this.state.currentTxn!.SlpChangeOutput.amount : 0;\n        const outputAmt = txn.SlpOutputs.reduce((p, c, i) => p.add(c), Big(0)).add(tokenAmt).sub(slpChangeAmt);\n        if (outputAmt.gt(unspentSlpAmt)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.LOW_SLP_INPUTS);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_SLP_INPUTS);\n        }\n\n        // TODO: actually check if slp change output will be needed\n        const changeDust = this.state.currentTxn!.SlpChangeOutput ? DUST_LIMIT : 0;\n        const opReturnSize = 10 + 32 + 9 * txn.SlpOutputs.length;\n\n        // check for sufficient bch balance when new slp output (bch dust) is added\n        const unspentBchAmt = Array.from(this.domWallet.Wallet.BchCoins).reduce((p, c, i) => p.add(c[1].satoshis), Big(0))\n        const outputBchAmt = txn.Outputs.reduce((p, c, i) => p.add(c[0].satoshis), Big(0)).add(DUST_LIMIT).add(changeDust).add(opReturnSize);  // .sub(bchChange);\n        // TODO subtract BCH change amount from the outputBchAmt\n        if (outputBchAmt.gt(unspentBchAmt)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.LOW_BCH_INPUTS);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n        }\n\n        // check input amount decimal places doesn't exceed\n        if (tokenAmt.lt(1)) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.TOO_MANY_SLP_DECIMAL_PLACES);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.TOO_MANY_SLP_DECIMAL_PLACES);\n        }\n      } else {\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_SLP_INPUTS);\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.ZERO_SLP_OUTPUT);\n        this.state.txnValidationErrors!.delete(TxnErrorTypes.TOO_MANY_SLP_DECIMAL_PLACES);\n      }\n    }\n\n    if (this.state.txnValidationErrors!.size > 0) {\n      this.forceUpdate();\n    }\n\n    return this.state.txnValidationErrors!.size;\n  }\n\n  private updateOutputAddress = (event: React.ChangeEvent<HTMLInputElement>) => {\n    if (bchaddr.isValidAddress(event.target.value)) {\n      this.setState({ outputAddressValid: true, outputAddressValue: event.target.value });\n      return;\n    }\n    this.setState({ outputAddressValid: false, outputAddressValue: event.target.value });\n  }\n\n  private updateSelectedToken = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    let tokenId = event.target.value;\n    if (tokenId !== this.state.selectedSlpTokenId) {\n      this.setState({ currentTxn: new TxBuilder(this.domWallet.Wallet)})\n    }\n    if (event.target.selectedIndex < this.domWallet.Wallet.TokenMetadata.size) {\n      this.setState({ selectedSlpTokenId: tokenId });\n    } else {\n      this.setState({ selectedSlpTokenId: \"bch\" });\n    }\n  }\n\n  private updateOutputValue = (event: React.ChangeEvent<HTMLInputElement>) => {\n    try {\n      Big(event.target.value);\n    } catch (_) {\n      this.setState({ outputAmountValid: false, outputAmountValue: event.target.value });\n      return;\n    }\n    \n    // check \n    if (Big(event.target.value).lt(546)) {\n      this.setState({ outputAmountValid: false, outputAmountValue: event.target.value });\n      return;\n    }\n\n    this.setState({ outputAmountValid: true, outputAmountValue: event.target.value });\n  }\n\n  private clearTransaction = () => {\n    this.state.txnValidationErrors!.clear();\n    this.setState({\n      outputAddressValue: \"\",\n      outputAmountValue: \"\",\n      currentTxn: new TxBuilder(this.domWallet.Wallet),\n      selectedSlpTokenId: \"bch\",\n    });\n  }\n\n  private sendTransaction = async () => {\n    try {\n      const { txnHex, fee, sendAmount } = await this.state.currentTxn!.SignTransaction(() => this.domWallet.Wallet.PrivateKey); \n      console.log(txnHex);\n      const ok = await Confirm(`Send: ${sendAmount} satoshis with fee: ${fee} satoshis?`);\n      if (ok) {\n        const txid = await this.domWallet.Wallet.SendTransaction(txnHex);\n        await Alert(`Broadcasted: ${txid}`);\n        this.clearTransaction();\n        this.forceUpdate();\n      }\n    } catch (err) {\n      // TODO: parse various error responses for better UI\n      await Alert(`Error: ${err.message}`);\n    }\n  }\n\n  private addOutput = () => {\n    if (this.validateAddOutput() > 0) {\n      return;\n    }\n\n    // get address and value\n    const addr = bchaddr.toCashAddress(this.state.outputAddressValue!);\n    const val = Big(this.state.outputAmountValue!);\n\n    // Add bch or slp output\n    switch (this.state.selectedSlpTokenId) {\n      case \"bch\":\n        if (!this.state.currentTxn!.AddBchOutput(new Address(addr), val.toNumber())) {\n          this.state.txnValidationErrors!.add(TxnErrorTypes.LOW_BCH_INPUTS);\n        } else {\n          this.state.txnValidationErrors!.delete(TxnErrorTypes.LOW_BCH_INPUTS);\n        }\n        break;\n      default:\n        const tokenAmt = this.getTokenAmount(val, this.state.selectedSlpTokenId!);\n        this.state.currentTxn!.AddSlpOutput(addr, tokenAmt, this.state.selectedSlpTokenId!);\n        break;\n    }\n\n    this.forceUpdate();\n  }\n\n  private getTokenAmount(val: Big, tokenId: string) {\n    const tm = this.domWallet.Wallet.TokenMetadata.get(tokenId)!;\n    let decimals: number;\n    if (tm.hasType1()) {\n      decimals = tm.getType1()!.getDecimals();\n    } else if (tm.hasNft1Group()) {\n      decimals = tm.getNft1Group()!.getDecimals();\n    } else if (tm.hasNft1Child()) {\n      decimals = 0;\n    } else {\n      throw Error(\"unknown token type\");\n    }\n    return val.mul(10**decimals);\n  }\n\n  private importMnemonic = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const userValue = event.target.value!;\n    if (!userValue) {\n      return;\n    }\n    try {\n      this.domWallet.Wallet.UpdateMnemonic(userValue);\n    } catch (_) {\n      console.log(`invalid wif: ${userValue}`);\n    }\n    this.setState({\n      address: this.domWallet.Wallet.Address.toCashAddress(),\n      showPrivKey: false,\n      showSlpAddressFormat: false,\n      // loading: true // TODO: provide UI indication that the wallet balances are loading.\n    });\n\n    this.domWallet.Wallet.LoadInitialBalances();\n  }\n\n  private getTokenTicker(tokenId?: string): string {\n    if (!tokenId) {\n      tokenId = this.state.selectedSlpTokenId!;\n    }\n    if (tokenId === \"bch\") {\n      return \"satoshis\";\n    }\n    if (!this.domWallet.Wallet.TokenMetadata!.has(tokenId)) {\n      return `?`;\n    }\n    const tm = this.domWallet.Wallet.TokenMetadata!.get(tokenId)!;\n    let nameBuf: Uint8Array;\n    if (tm.hasType1()) {\n      nameBuf = tm.getType1()!.getTokenTicker_asU8();\n    } else if (tm.hasNft1Group()) {\n      nameBuf = tm.getNft1Group()!.getTokenTicker_asU8();\n    } else if (tm.hasNft1Child()) {\n      nameBuf = tm.getNft1Child()!.getTokenTicker_asU8();\n    } else {\n      throw Error(\"unknown token type\");\n    }\n    return Buffer.from(nameBuf).toString(\"utf8\");\n  }\n\n  private getTokenName(tokenId: string): string {\n    if (tokenId === \"bch\") {\n      return \"Bitcoin Cash\"\n    }\n    if (!this.domWallet.Wallet.TokenMetadata!.has(tokenId)) {\n      return `${tokenId.slice(0, 10)}...${tokenId.slice(54, 64)}`;\n    }\n    const tm = this.domWallet.Wallet.TokenMetadata!.get(tokenId)!;\n    let nameBuf: Uint8Array;\n    if (tm.hasType1()) {\n      nameBuf = tm.getType1()!.getTokenName_asU8();\n    } else if (tm.hasNft1Group()) {\n      nameBuf = tm.getNft1Group()!.getTokenName_asU8();\n    } else if (tm.hasNft1Child()) {\n      nameBuf = tm.getNft1Child()!.getTokenName_asU8();\n    } else {\n      throw Error(\"unknown token type\");\n    }\n    return Buffer.from(nameBuf).toString(\"utf8\");\n  }\n\n  private getTokenTypeString(tokenId: string): string {\n    const tm = this.domWallet.Wallet.TokenMetadata.get(tokenId);\n    if (!tm) {\n      return \"?\";\n    }\n    switch (tm.getTypeMetadataCase()) {\n      case TokenMetadata.TypeMetadataCase.TYPE1:\n        return \"Token\";\n      case TokenMetadata.TypeMetadataCase.NFT1_GROUP:\n        return \"NFT Group\";\n      case TokenMetadata.TypeMetadataCase.NFT1_CHILD:\n        return \"NFT\";\n      default:\n        return \"?\";\n    }\n  }\n\n  private getSlpAmountString(amount: Big, tokenId?: string): string {\n    if (!tokenId) {\n      tokenId = this.state.selectedSlpTokenId!;\n    }\n    const tm = this.domWallet.Wallet.TokenMetadata!.get(tokenId)!;\n    // if (!tm) {\n    //   return \"...\";\n    // }\n    let decimals: number;\n    if (tm.hasType1()) {\n      decimals = tm.getType1()!.getDecimals();\n    } else if (tm.hasNft1Group()) {\n      decimals = tm.getNft1Group()!.getDecimals();\n    } else if (tm.hasNft1Child()) {\n      decimals = 0;\n    } else {\n      throw Error(\"unknown token type\");\n    }\n    return amount.div(10 ** decimals).toFixed();\n  }\n\n  private toggleAddrFormat = async () => {\n    let address = this.domWallet.Wallet.Address.toCashAddress();\n    if (!this.state.showSlpAddressFormat) {\n      address = bchaddr.toSlpAddress(address);\n    }\n    if (!this.state.useMainnet) {\n      address = bchaddr.toTestnetAddress(address);\n    }\n    await this.setState({\n      showSlpAddressFormat: !this.state.showSlpAddressFormat,\n      address,\n    });\n  }\n\n  private toggleMnemonic = () => {\n    this.setState({\n      showPrivKey: !this.state.showPrivKey\n    });\n  }\n\n}\n\nexport default App;\n","export default __webpack_public_path__ + \"static/media/logo.a5dd61ec.svg\";","export class CacheSet<T> {\n  private set = new Set<T>();\n  private list: T[] = [];\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n  }\n\n  public [Symbol.iterator]() {\n    return this.list.values();\n  }\n\n  get length(): number {\n    return this.list.length;\n  }\n\n  public push(item: T) {\n    this.set.add(item);\n    if (this.maxSize > 0 && this.set.size > this.maxSize) {\n    this.shift();\n    }\n    return this.list.push(item);\n  }\n\n  public has(item: T) {\n    return this.set.has(item);\n  }\n\n  public delete(item: T) {\n    if (this.set.delete(item)) {\n      this.list = this.list.filter(k => k !== item);\n    }\n  }\n\n  public toSet() {\n    return this.set;\n  }\n\n  public shift(): T | undefined {\n    const item = this.list.shift();\n    if (item) {\n      this.set.delete(item);\n    }\n    return item;\n  }\n\n  public pop(): T | undefined {\n    const item = this.list.pop();\n    if (item) {\n      this.set.delete(item);\n    }\n    return item;\n  }\n\n  public clear() {\n    this.list = [];\n    this.set.clear();\n  }\n}\n  ","import { BlockNotification, GrpcClient, Transaction, TransactionNotification } from \"grpc-bchrpc-web\";\nimport Utils from \"./Utils\";\n\nexport class Network {\n\n  private networkUrl: string;\n  private subscriptions = { txn: false, blockInfo: false, blockData: false };\n  private blockHeight = -1;\n\n  constructor(url: string) {\n    this.networkUrl = url;\n  }\n\n  public async SendTransaction(txnHex: string, callback?: () => any): Promise<string> {\n    const client = new GrpcClient({ url: this.networkUrl });\n    let res = await client.submitTransaction({txnHex});\n    if (callback) {\n      callback();\n    }\n    return Buffer.from(res.getHash_asU8().reverse()).toString(\"hex\");\n  }\n\n  public async GetTransaction(txid: string) {\n    const client = new GrpcClient({ url: this.networkUrl });\n    return await client.getTransaction({hash: txid, reversedHashOrder: true}); \n  }\n\n  public async GetTokenMetadata(tokenIds: string[]) {\n    const client = new GrpcClient({url: this.networkUrl});\n    return await client.getTokenMetadata(tokenIds);\n  }\n\n  public async GetAddressTransactions(address: string, sinceBlock?: number) {\n    const client = new GrpcClient({ url: this.networkUrl });\n    const slpEnabled = (await client.getBlockchainInfo()).getSlpIndex();\n    if (! slpEnabled) {\n      throw Error(\"connected bchd does not have slp index enabled\");\n    }\n\n    return await client.getAddressTransactions({ address });\n  }\n\n  public async Subscribe(addresses: string[], onTransactionNotification: (txn: Transaction) => any) {\n\n    // setup a self-healing stream for mempool transactions\n    const createTxnStream = async () => {\n      if (this.subscriptions.txn) {\n        console.log(\"Txn stream already connected\");\n        return;\n      }\n      const client = new GrpcClient({ url: this.networkUrl });\n      const txnStream = await client.subscribeTransactions({\n        includeMempoolAcceptance: true,\n        includeBlockAcceptance: false,\n        includeSerializedTxn: false,\n        addresses: addresses\n      });\n\n      txnStream.on(\"end\", async (error) => {\n        this.subscriptions.txn = false;\n        while (true) {\n          await Utils.sleep(500);\n          try {\n            console.log(`[WALLET] trying to re-establish txn data stream...`);\n            await createTxnStream();\n            break;\n          } catch (error) {\n            console.log(error);\n          }\n        }\n      });\n\n      txnStream.on(\"data\", async (data: TransactionNotification) => {\n        this.subscriptions.txn = true;\n        let txn = data.getUnconfirmedTransaction()!.getTransaction()!;\n        onTransactionNotification(txn);\n      });\n      console.log(`[WALLET] txn data stream established.`);\n\n    };\n    await createTxnStream();\n\n    // setup a self-healing stream for getting serialized block data\n    const createBlockDataStream = async () => {\n      if (this.subscriptions.blockData) {\n        console.log(\"Txn stream already connected\");\n        return;\n      }\n      const client = new GrpcClient({ url: this.networkUrl });\n      const blockDataStream = await client.subscribeBlocks({ includeSerializedBlock: true });\n      blockDataStream.on(\"end\", async (error) => {\n        this.subscriptions.blockData = false;\n        while (true) {\n          await Utils.sleep(500);\n          try {\n            console.log(`[WALLET] trying to re-establish block data stream...`);\n            await createBlockDataStream();\n            break;\n          } catch (_) {}\n        }\n      });\n      blockDataStream.on(\"data\", async (data: BlockNotification) => {\n        this.subscriptions.blockData = true;\n        // const blockBuf = Buffer.from(data.getSerializedBlock_asU8());\n        // const block = new Block(blockBuf);\n        console.log(\"BLOCK found\");\n        // for (const txn of block.transactions) {\n        //   // todo...\n          \n        // }\n      });\n      console.log(`[WALLET] block data stream established.`);\n    };\n    await createBlockDataStream();\n\n    // setup a self-healing stream for getting block height\n    const createBlockInfoStream = async () => {\n      if (this.subscriptions.blockInfo) {\n        console.log(\"Txn stream already connected\");\n        return;\n      }\n      const client = new GrpcClient({ url: this.networkUrl });\n      const blockInfoStream = await client.subscribeBlocks();\n      blockInfoStream.on(\"end\", async (error) => {\n        this.subscriptions.blockInfo = false;\n        while (true) {\n          await Utils.sleep(500);\n          try {\n            console.log(`[WALLET] trying to re-establish block info stream...`);\n            await createBlockInfoStream();\n            break;\n          } catch (_) {}\n        }\n      });\n      blockInfoStream.on(\"data\", async (data: BlockNotification) => {\n        this.subscriptions.blockInfo = true;\n        const height = data.getBlockInfo()!.getHeight();\n        this.blockHeight = height;\n        console.log(`Block found: ${height}`);\n      });\n      console.log(`[WALLET] block info stream established.`);\n    };\n    await createBlockInfoStream();\n  }\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { WalletStorage } from \"./Interfaces\";\n\nexport class BrowserLocalStorage implements WalletStorage {\n    public GetSeed() {\n        return localStorage.getItem(\"bitcore-fun-seed\");\n    }\n    public SetSeed(seed: string) {\n        return localStorage.setItem(\"bicore-fun-seed\", seed);\n    }\n}\n","import { App, WalletStorage } from \"./Interfaces\";\nimport { Wallet } from \"./Wallet\";\nimport { BrowserLocalStorage } from \"./Storage\";\nimport { Network } from \"./Network\";\n    \n// DomWallet is the most simple wallet implementation intended for prototyping purposes\n// by default using the browser's local storage for storing private keys.\nexport class DomWallet {\n    public Ready = false;\n    public Network = new Network(\"https://bchd.ny1.simpleledger.io\");\n    public Wallet: Wallet;\n    public Storage = new BrowserLocalStorage();\n\n    constructor(app: App, storage?: WalletStorage, network?: Network) {\n        if (window === undefined) {\n            throw Error(\"access to 'window' is not available.\");\n        }\n        if (storage) {\n            this.Storage = storage;\n        }\n        if (network) {\n            this.Network = network;\n        }\n        this.Wallet = new Wallet(this.Storage, this.Network, app);\n    }\n};\n\n// NodeWallet is \nexport class NodeWallet {\n// todo...   \n}\n","/* eslint-disable import/first */\nglobal.Buffer = require(\"buffer/\").Buffer;\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\nexports.default = {\n    genesis: (ticker, name, documentUrl, documentHash, decimals, mintBatonVout, quantity) => util_1.createOpReturnGenesis(0x01, ticker, name, documentUrl, documentHash, decimals, mintBatonVout, quantity),\n    mint: (tokenIdHex, mintBatonVout, quantity) => util_1.createOpReturnMint(0x01, tokenIdHex, mintBatonVout, quantity),\n    send: (tokenIdHex, slpAmounts) => util_1.createOpReturnSend(0x01, tokenIdHex, slpAmounts),\n};\n//# sourceMappingURL=tokentype1.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst util_1 = require(\"./util\");\nexports.default = {\n    Group: {\n        genesis: (ticker, name, documentUrl, documentHash, decimals, mintBatonVout, quantity) => util_1.createOpReturnGenesis(0x81, ticker, name, documentUrl, documentHash, decimals, mintBatonVout, quantity),\n        mint: (tokenIdHex, mintBatonVout, quantity) => util_1.createOpReturnMint(0x81, tokenIdHex, mintBatonVout, quantity),\n        send: (tokenIdHex, slpAmounts) => util_1.createOpReturnSend(0x81, tokenIdHex, slpAmounts),\n    },\n    Child: {\n        genesis: (ticker, name, documentUrl, documentHash) => util_1.createOpReturnGenesis(0x41, ticker, name, documentUrl, documentHash, 0, null, new bignumber_js_1.default(1)),\n        send: (tokenIdHex, slpAmounts) => util_1.createOpReturnSend(0x41, tokenIdHex, slpAmounts),\n    }\n};\n//# sourceMappingURL=nft1.js.map","import Big from \"big.js\";\nimport { Address, PrivateKey, Script, Transaction } from \"bitcore-lib-cash\";\nimport * as mdm from \"slp-mdm\";\nimport { Wallet } from \"./Wallet\";\nimport { tokenId } from \"./Interfaces\";\nimport Utils from \"./Utils\";\n\nexport const DUST_LIMIT = 546; // sats\nconst FEE_RATE = 1;            // sats/byte\n\nexport enum SlpVersionType {\n  \"TokenVersionType1\" = 1,\n  \"TokenVersionType1_NFT_Child\" = 65,\n  \"TokenVersionType1_NFT_Group\" = 129\n}\n\nexport class TxBuilder {\n  private wallet: Wallet;\n  private txn = new Transaction();\n  private tokenId = \"bch\";\n  private slpOpreturnMessage?: Buffer;\n  private slpChangeAmt?: { amount: Big, index: number };\n  private slpOutputs = new Array<Big>();\n\n  public get TokenId(): string {\n    return this.tokenId;\n  }\n\n  // TODO: make a protected copy this.slpOutputs\n  public get SlpOutputs(): Array<Big> {\n    if (this.slpChangeAmt) {\n      return [...this.slpOutputs, this.slpChangeAmt!.amount];\n    };\n    return this.slpOutputs;\n  }\n\n  public get SlpChangeOutput(): { amount: Big, index: number } | null {\n    if (!this.slpChangeAmt) {\n      return null;\n    }\n    return { amount: Big(this.slpChangeAmt.amount.toFixed()), index: this.slpChangeAmt.index };\n  }\n\n  // TODO: make a protected copy of txn.inputs\n  public get Inputs(): Array<Transaction.Input> {\n    return this.txn.inputs;\n  }\n\n  // TODO: make a protected copy of txn.outputs\n  public get Outputs(): Array<[Transaction.Output, Big?]> {\n    return this.txn.outputs.map((o, i) => {\n      let slpAmt = Big(0);\n      if (i > 0 && i-1 < this.slpOutputs.length) {\n        slpAmt.add(this.slpOutputs[i-1]);\n      } else if (this.slpChangeAmt && i === this.slpOutputs.length+1) {\n        slpAmt.add(this.slpChangeAmt.amount);\n        if (this.slpChangeAmt.index !== i) {\n          throw Error(\"slp change has wrong index\");\n        }\n      }\n      return [o, slpAmt];\n    });\n  }\n\n  constructor(wallet: Wallet) {\n    this.wallet = wallet;\n  }\n\n  public AddSlpOutput(address: string, amount: Big, tokenId: string): void {\n    if (this.tokenId !== tokenId) {\n      this.slpOutputs = [];\n      this.tokenId = tokenId;\n    }\n    if (tokenId === \"bch\") {\n      throw Error(\"can't add slp token with bch token id\")\n    }\n\n    // remove bch change\n    // @ts-ignore\n    this.txn._changeScript = undefined;\n    // @ts-ignore\n    if (this.txn._changeIndex !== undefined) {\n      // @ts-ignore\n      this.txn.removeOutput(this.txn._changeIndex);\n      // @ts-ignore\n      this.txn._changeIndex = undefined;\n    }\n\n    if (this.slpChangeAmt) {\n      this.txn.removeOutput(this.slpChangeAmt!.index);\n      this.slpChangeAmt = undefined;\n    }\n\n    const index = this.slpOutputs.length + 1;\n    this.txn.addOutput(new Transaction.Output({\n      script: new Script(new Address(address)),\n      satoshis: DUST_LIMIT\n    }), index);\n    this.slpOutputs.push(amount);\n\n    this.addSlpInputs(tokenId);\n    this.addBchInputs();\n  }\n\n  public AddBchOutput(address: Address, amount: number): boolean {\n    this.txn.to(address, amount);\n    let bool = this.addBchInputs();\n    return bool;\n  }\n\n  public async SignTransaction(getKeys: () => PrivateKeys|Promise<PrivateKeys>): Promise<SignedTxInfo> {\n    let pk = await getKeys();\n    this.txn.sign(pk);\n    const txnHex = this.txn.serialize();\n    let fee = this.txn.inputAmount - this.txn.outputAmount;\n    return { txnHex, fee, sendAmount: this.txn.outputAmount };\n  }\n\n  // addBchInputs selects coins from smallest value to largest adding them to\n  // the transaction and checking for sufficient fee. \n  // If sufficient inputs are available true is returned, otherwise false is returned.\n  //\n  // TODO: respect data banks (coin banks provide better privacy, security, and smart contract interoperability)\n  // TODO: abstract this as a coin chooser object added to the wallet\n  private addBchInputs(): boolean { // coins: Map<outpoint, { amount: Big, address: Address}>): boolean {\n    this.txn.change(this.wallet.Address.toCashAddress());\n\n    const checkInputs = () => {\n      this.txn.feePerByte(FEE_RATE);\n      let feeRate = Wallet.GetFeeRate(this.txn);\n\n      // let changeAmt = 0;\n      // if (this.txn.getChangeOutput()) {\n      //   changeAmt = this.txn.getChangeOutput()!.satoshis;\n      // }\n      // console.log(`input amt: ${this.txn.inputAmount}`);\n      // console.log(`output amt: ${this.txn.outputAmount}`);\n      // console.log(`change amt: ${changeAmt}`);\n      // console.log(`fee rate: ${feeRate}`);\n\n      if (this.txn.inputAmount >= this.txn.outputAmount && feeRate >= FEE_RATE) {\n        return true;\n      }\n      return false;\n    };\n\n    let bchCoins = Array.from(this.wallet.BchCoins).sort((a, b) => a[1].satoshis.sub(b[1].satoshis).toNumber());\n\n    for (const coin of bchCoins) {\n\n      // don't add same coin twice\n      let skipCoin = false;\n      const txid = coin[0].slice(0, 64);\n      const vout = Buffer.from(coin[0].slice(64), \"hex\").readUInt32BE(0);\n      for (const input of this.txn.inputs) {\n        if (txid === input.prevTxId.toString(\"hex\") && vout === input.outputIndex) {\n          skipCoin = true;\n          break;\n        }\n      }\n      if (skipCoin) {\n        continue;\n      }\n\n      // check if current input amount is sufficient\n      if (this.txn.outputs.length > 0) {\n        if (checkInputs()) {\n          return true;\n        }\n      }\n\n      // add the input\n      this.txn.addInput(new Transaction.Input.PublicKeyHash({\n        output: new Transaction.Output({\n          script: Script.buildPublicKeyHashOut(coin[1].address),\n          satoshis: coin[1].satoshis.toNumber()\n        }),\n        prevTxId: Buffer.from(txid, \"hex\"),\n        outputIndex: vout,\n        script: Script.empty()\n      }));\n      this.txn.feePerByte(FEE_RATE);\n    }\n\n    return checkInputs();\n  }\n\n  private createMd(tokenId: string, amounts: Big[]) {\n    let amts = amounts.map(n => new mdm.BN(n.toFixed()));\n    let tm = this.wallet.TokenMetadata.get(tokenId)!;\n    switch (tm.getTokenType()) {\n      case SlpVersionType.TokenVersionType1:\n        return mdm.TokenType1.send(tokenId, amts);\n      case SlpVersionType.TokenVersionType1_NFT_Group:\n        return mdm.NFT1.Group.send(tokenId, amts);\n      case SlpVersionType.TokenVersionType1_NFT_Child:\n        return mdm.NFT1.Child.send(tokenId, [new mdm.BN(1)]);\n    }\n  };\n\n  // addSlpInputs selects slp coins and updates variables slpOutputs and slpChange as required.\n  // \n  private addSlpInputs(tokenId: tokenId) {\n\n    // get coins we can access for this slp token\n    let slpCoins = Array.from(this.wallet.SlpCoins.get(tokenId)!).sort((a, b) => a[1].amount.sub(b[1].amount).toNumber());\n\n    // method to check inputs >= outputs\n    const checkSlpInputs = (): boolean => {\n\n      if (this.slpChangeAmt) {\n        this.txn.removeOutput(this.slpChangeAmt!.index);\n        this.slpChangeAmt = undefined;\n      }\n\n      const slpInputAmt = this.txn.inputs.reduce((p, _, i) => {\n        const slpCoins = this.wallet.SlpCoins.get(tokenId)!;\n        if (!slpCoins) {\n          return Big(0);\n        }\n        const outpoint = Utils.outpointToKey(this.txn.inputs[i].prevTxId, this.txn.inputs[i].outputIndex, true);\n        if (slpCoins.has(outpoint)) {\n          return p.add(slpCoins.get(outpoint)!.amount);\n        }\n        return p;\n      }, Big(0));\n\n      const slpOutputAmt = this.slpOutputs.reduce((p, c, i) => p.add(c), Big(0));\n\n      // console.log(`slp input amt: ${slpInputAmt}`);\n      // console.log(`slp output amt: ${slpOutputAmt}`);\n\n      if (slpInputAmt.gt(slpOutputAmt)) {\n        // set slp change output here\n        this.slpChangeAmt = { amount: slpInputAmt.minus(slpOutputAmt), index: this.slpOutputs.length + 1 };\n        //console.log(`slp change amt: ${this.slpChangeAmt.amount}`);\n\n        // set the slp change dust output\n        this.txn.addOutput(new Transaction.Output({\n          //@ts-ignore\n          script: new Script(this.wallet.Address!),\n          satoshis: DUST_LIMIT\n        }), this.slpChangeAmt!.index);\n      }\n\n      if (slpInputAmt.gte(slpOutputAmt)) {\n        // set the slp metadata message\n        if (this.slpOpreturnMessage) {\n          this.txn.removeOutput(0);\n        }\n        const outputs = this.SlpChangeOutput ? [ ...this.slpOutputs, this.slpChangeAmt!.amount ] : this.slpOutputs;\n        this.slpOpreturnMessage = this.createMd(tokenId, outputs);\n        this.txn.addOutput(new Transaction.Output({\n          script: this.slpOpreturnMessage,\n          satoshis: 0\n        }), 0);\n      \n        return true;\n      }\n\n      return false;\n    };\n\n    // loop through available slp coins to check if inputs are needed\n    for (const coin of slpCoins) {\n\n      // don't add same coin twice\n      let skipCoin = false;\n      const txid = coin[0].slice(0, 64);\n      const vout = Buffer.from(coin[0].slice(64), \"hex\").readUInt32BE(0);\n      for (const input of this.txn.inputs) {\n        if (txid === input.prevTxId.toString(\"hex\") && vout === input.outputIndex) {\n          skipCoin = true;\n          break;\n        }\n      }\n      if (skipCoin) {\n        continue;\n      }\n\n      // check if current input amount is sufficient\n      if (this.slpOutputs.length > 0) {\n        if (checkSlpInputs()) {\n          return true;\n        }\n      }\n\n      // add the slp input\n      this.wallet.slpOutpointCache.set(coin[0], { amount: coin[1].amount, satoshis: coin[1].satoshis, address: coin[1].address, tokenId });\n      this.txn.addInput(new Transaction.Input.PublicKeyHash({\n        output: new Transaction.Output({\n          script: Script.buildPublicKeyHashOut(coin[1].address),\n          satoshis: coin[1].satoshis.toNumber()\n        }),\n        prevTxId: Buffer.from(txid, \"hex\"),\n        outputIndex: vout,\n        script: Script.empty()\n      }));\n    }\n\n    return checkSlpInputs();\n  }\n\n}\n\nexport type PrivateKeys = Array<PrivateKey | string> | PrivateKey | string\nexport type SignedTxInfo = { txnHex: string, fee: number, sendAmount: number }\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nexports.BN = bignumber_js_1.default;\nconst tokentype1_1 = __importDefault(require(\"./tokentype1\"));\nexports.TokenType1 = tokentype1_1.default;\nconst nft1_1 = __importDefault(require(\"./nft1\"));\nexports.NFT1 = nft1_1.default;\n//# sourceMappingURL=index.js.map","import { Big } from \"big.js\";\nimport * as bip32 from \"bip32\";\nimport * as bip39 from \"bip39\";\nimport { Address, PrivateKey, Transaction as Txn } from \"bitcore-lib-cash\";\nimport { TokenMetadata, Transaction } from \"grpc-bchrpc-web\";\n\nimport { App, outpoint, tokenId, WalletStorage } from \"./Interfaces\";\nimport { CacheSet } from \"../CacheSet\";\nimport { Network } from \"./Network\";\nimport Utils from \"./Utils\";\n\nconst txidsSeen = new CacheSet<string>(100000);\nconst addressPath = \"m/44'/245'/0'/0/0\";\n\nexport class Wallet {\n\n  public slpOutpointCache = new Map<outpoint, { amount: Big, address: Address, satoshis: Big, tokenId: string}>();\n\n  public static EstimateTxnSize(txn: Txn) {\n    return txn._estimateSize();\n  }\n\n  public static GetFeeRate(txn: Txn) {\n    let size = Wallet.EstimateTxnSize(txn);\n    console.log(`estimated size: ${size}`);\n\n    const fee = txn.inputAmount - txn.outputAmount;\n    if (!fee || fee < 0) {\n      return 0;\n    }\n    let rate = fee / size;\n    console.log(`estimated fee rate: ${rate}`);\n    return rate;\n  }\n\n  private storage: WalletStorage;\n  private network: Network;\n  private parent?: App;\n  private mnemonic: string;\n  private privateKey: PrivateKey;\n\n  // // this will be used by the application api to access coins\n  // private banks = new Map<bank, { addresses: Set<address>, domain: string }>();\n  // private addresses = new Map<address, { bank: string, kind: AddressKind, info: number|Buffer }>();\n  // private transactions = new Map<txid, { height: number }>();\n\n  private bchTxi = new Map<outpoint, { satoshis: Big, address: Address}>();\n  private bchTxo = new Map<outpoint, { satoshis: Big, address: Address}>();\n  private slpTxi = new Map<tokenId, Map<outpoint, { amount: Big, address: Address, satoshis: Big }>>();\n  private slpTxo = new Map<tokenId, Map<outpoint, { amount: Big, address: Address, satoshis: Big }>>();\n\n  // private bch = new Map<bank, { bchTxi: Map<address, Map<outpoint, Big>>, bchTxo: Map<address, Map<outpoint, Big>> }>();\n  // private slp = new Map<bank, Map<tokenId, { slpTxi: Map<address, Map<outpoint, Big>>, slpTxo: Map<address, Map<outpoint, Big>> }>>();\n\n  private tokenMetadata = new Map<tokenId, TokenMetadata>();\n  private loadingBalance = false;\n\n  constructor(storage: WalletStorage, network: Network, parent?: App) { // bankPermissions: bank[]) {\n    this.storage = storage;\n    this.network = network;\n    this.parent = parent;\n    this.mnemonic = bip39.generateMnemonic();\n    let seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.Mnemonic));\n    let child = seed.derivePath(addressPath);\n    this.privateKey = new PrivateKey(child.toWIF());\n    if (this.storage.GetSeed() === null) {\n      this.storage.SetSeed(this.Mnemonic);\n    } else {\n      this.mnemonic = this.storage.GetSeed()!;\n      seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.Mnemonic));\n      child = seed.derivePath(addressPath);\n      this.privateKey = new PrivateKey(child.toWIF());\n    }\n\n    this.LoadInitialBalances();\n  }\n\n  public get Mnemonic() {\n    return this.mnemonic;\n  }\n\n  public get XPub() {\n    let seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.Mnemonic)).neutered();\n    return seed.toBase58();\n  }\n\n  public get PrivateKey() {\n    return this.privateKey.toWIF();\n  }\n\n  public set PrivateKey(_bip39: string) {\n    if (! bip39.validateMnemonic(_bip39)) {\n      throw Error(\"invalid mnemonic\");\n    }\n    const seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.mnemonic));\n    const child = seed.derivePath(addressPath);\n    this.privateKey = new PrivateKey(child.toWIF());\n    this.LoadInitialBalances();\n  }\n\n  public get Address() { return this.privateKey.toAddress(); }\n\n  // TODO: make a safe copy\n  public get BchCoins() {\n    let coins = new Map<outpoint, { satoshis: Big, address: Address }>();\n    this.bchTxo.forEach((dat, outpoint) => {\n      coins.set(outpoint, dat);\n      if (this.bchTxi.has(outpoint)) {\n        coins.delete(outpoint);\n      }\n    });\n    return coins;\n  }\n\n  // TODO: make a safe copy\n  public get SlpCoins() {\n    let coins = new Map<tokenId, Map<outpoint, { amount: Big, address: Address, satoshis: Big }>>();\n    this.slpTxo.forEach((_coins, tokenId) => {\n      let coinMap: Map<outpoint, { amount: Big, address: Address, satoshis: Big }>;\n      if (!coins.has(tokenId)) {\n        let coinMap = new Map<outpoint, { amount: Big, address: Address, satoshis: Big }>();\n        coins.set(tokenId, coinMap);\n      }\n      coinMap = coins.get(tokenId)!;\n      let inputs = this.slpTxi.get(tokenId);\n      _coins.forEach((dat, outpoint) => {\n        coinMap.set(outpoint, dat);\n        if (!this.slpOutpointCache.has(outpoint)) {\n          this.slpOutpointCache.set(outpoint, { amount: dat.amount, satoshis: dat.satoshis, address: dat.address, tokenId });\n        }\n        if (inputs && inputs!.has(outpoint)) {\n          coinMap.delete(outpoint);\n        }\n      });\n\n    });\n    return coins;\n  }\n\n  public get TokenMetadata() { return this.tokenMetadata; }\n\n  public isMine(address: string) {\n    if (address === this.Address.toCashAddress()) {\n      return true;\n    }\n    return false;\n  }\n\n  // GetChangeOutput returns an array of transaction outputs that\n  // will be sent to this wallet.  Note that txn.getChangeOutput() has\n  // been found to be unreliable perhaps due to the way outputs are added\n  // to transactions by this wallet class.\n  public GetChangeOutput(txn: Txn): Array<Txn.Output> {\n    let change: Array<Txn.Output> = [];\n    txn.outputs.forEach(output => { \n      if (this.isMine(output.script.toAddress().toCashAddress())) {\n        change.push(output);\n      }\n    });\n\n    return change;\n  }\n\n  public async LoadInitialBalances() {\n    if (this.loadingBalance) {\n      return;\n    }\n    this.loadingBalance = true;\n    const res = await this.network.GetAddressTransactions(this.Address.toCashAddress());\n    await this.indexTransactionIO(res.getConfirmedTransactionsList());\n    await this.indexTransactionIO(res.getUnconfirmedTransactionsList()!.map(o => o.getTransaction()!));\n    this.loadingBalance = false;\n    this.updateParent();\n  }\n\n  public UpdateMnemonic(m: string) {\n    if (! bip39.validateMnemonic(m)) {\n      throw new Error(\"invalid mnemonic\");\n    }\n    this.mnemonic = m;\n    localStorage.setItem(\"bitcore-fun-seed\", this.Mnemonic);\n    const seed = bip32.fromSeed(bip39.mnemonicToSeedSync(this.Mnemonic));\n    const child = seed.derivePath(addressPath);\n    this.privateKey = new PrivateKey(child.toWIF());\n    this.LoadInitialBalances();\n  }\n\n  public GetBchBalance(): Big {\n    const inputAmt = Array.from(this.bchTxi!).reduce((p, c) => p.add(c[1].satoshis), Big(0));\n    return Array.from(this.bchTxo!).reduce((p, c) => p.add(c[1].satoshis), Big(0)).sub(inputAmt);\n  }\n\n  public GetSlpBalances(): Map<tokenId, Big> {\n    const slpBals = new Map<tokenId, Big>();\n    Array.from(this.slpTxi!).forEach((coins) => {\n      slpBals.set(coins[0], Array.from(coins[1]).reduce((p, c) => p.add(c[1].amount), Big(0)));\n    });\n    Array.from(this.slpTxo!).forEach((coins) => {\n      let bal = slpBals.get(coins[0])!;\n      if (!bal) { bal = Big(0); }\n      let outs = Array.from(coins[1]).reduce((p, c) => p.add(c[1].amount), Big(0));\n      slpBals.set(coins[0], outs.sub(bal));\n    });\n    return slpBals;\n  }\n\n  private updateParent = () => {\n    if (this.parent) {\n      this.parent.UpdateWalletUI();\n    }\n  }\n\n  public Subscribe() {\n    const cb = (txn: Transaction) => {\n      this.processNewTransaction(txn);\n    };\n    this.network.Subscribe([this.Address.toCashAddress()], cb);\n  }\n\n  private async processNewTransaction(txn: Transaction) {\n    const txid = Utils.hashToTxid(txn.getHash_asU8());\n    if (txidsSeen.has(txid)) {\n      return;\n    }\n    txidsSeen.push(txid);\n    console.log(`${txid}`);\n    await this.indexTransactionIO([txn]);\n    this.updateParent();\n  };\n\n  public async SendTransaction(txnHex: string) {\n    const txid = await this.network.SendTransaction(txnHex);\n    const txn = await this.network.GetTransaction(txid);\n    this.processNewTransaction(txn.getTransaction()!);\n    return txid;\n  }\n\n  private async indexTransactionIO(txns: Transaction[]) {\n    let tokenIds = new Set<string>();\n\n    for (const tx of txns) {\n      for (const inp of tx.getInputsList()) {\n        if (!this.Address.toCashAddress().includes(inp.getAddress())) {\n          continue;\n        }\n        const op = Utils.outpointToKey(inp.getOutpoint()!.getHash_asU8(), inp.getOutpoint()!.getIndex());\n        if (inp.hasSlpToken()) {\n          const _tokenId = Buffer.from(inp.getSlpToken()!.getTokenId_asU8()).toString(\"hex\");\n          tokenIds.add(_tokenId);\n          if (!this.slpTxi.has(_tokenId)) {\n            this.slpTxi.set(_tokenId, new Map<outpoint, { amount: Big, address: Address, satoshis: Big }>());\n          }\n          this.slpTxi.get(_tokenId)!.set(op, { amount: Big(inp.getSlpToken()!.getAmount()), address: new Address(inp.getAddress()), satoshis: Big(inp.getValue()) });\n        } else {\n          this.bchTxi.set(op, { satoshis: Big(inp.getValue()), address: new Address(inp.getAddress()) });\n        }\n      }\n      for (const out of tx.getOutputsList()) {\n        if (!out.getAddress() || !this.Address.toCashAddress().includes(out.getAddress())) {\n          continue;\n        }\n        const op = Utils.outpointToKey(tx.getHash_asU8(), out.getIndex());\n        if (out.hasSlpToken()) {\n          const _tokenId = Buffer.from(out.getSlpToken()!.getTokenId_asU8()).toString(\"hex\");\n          tokenIds.add(_tokenId);\n          if (!this.slpTxo.has(_tokenId)) {\n            this.slpTxo.set(_tokenId, new Map<outpoint, { amount: Big, address: Address, satoshis: Big }>());\n          }\n          this.slpTxo.get(_tokenId)!.set(op, { amount: Big(out.getSlpToken()!.getAmount()), address: new Address(out.getAddress()), satoshis: Big(out.getValue()) });\n        } else {\n          this.bchTxo.set(op, { satoshis: Big(out.getValue()), address: new Address(out.getAddress()) });\n        }\n      }\n    }\n\n    const tmRes = await this.network.GetTokenMetadata([...tokenIds.keys()]);\n    tmRes.getTokenMetadataList().forEach(tm => this.tokenMetadata.set(Buffer.from(tm.getTokenId_asU8()).toString(\"hex\"), tm));\n  }\n}\n"],"sourceRoot":""}